<!DOCTYPE html>
<html>
  <head>
    <title>Boosted Bare Bones Bash</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700);
      @import url(https://fonts.googleapis.com/css?family=Roboto+Slab:300,300i,400,400i,700);
      @import url(https://fonts.googleapis.com/css?family=Raleway:300,300i,400,400i,700);


      /* font/size formatting */
      body {
        font-family: 'Raleway', sans-serif;
        font-weight: 300;
        color: #000000;
      }

      h1 {
        font-family: 'Roboto Slab', sans-serif;
        color: #7570b3;
        font-weight: 400;
        font-size: 40px;
      }

      h2 {
        font-family: 'Roboto Slab', sans-serif;
        font-weight: 400;
        font-size: 30px;
        color: #7570b3;
      }

      h3 {
        font-family: 'Raleway', sans-serif;
        color: #7570b3;
      }

      /* improve font size modifications - https://github.com/yihui/xaringan/wiki/Font-Size */

      .huge { font-size: 160% }
      .large { font-size: 130% }
      .medium { font-size: 90% }
      .small { font-size: 70% }
      .tiny{font-size: 40%}

      /* https://github.com/gnab/remark/issues/305#issuecomment-403309989 */
      blockquote {
        border-left: 0.3em solid #ccc;
        padding: 0 15px;
        font-style: italic;
        color: #777;
        quotes: "\201C""\201D""\2018""\2019";
        font-size: 18px;
      }

      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono'; color: grey;
      }

      /* Two-column layouts */
      .cols {
        display: flex;
      }
      .left-column  { width: 49%; float: left; }
      .right-column { width: 49%; float: right; }

      .left-column-33  { width: 33%; float: left; }
      .right-column-66 { width: 66%; float: right; }

      .left-column-66  { width: 66%; float: left; }
      .right-column-33 { width: 33%; float: right; }

      .right-column ~ p { clear: both; }
      .right-column ~ ul { clear: both; }

      /* use with e.g. <div class=vertical-center"> */
      .vertical-center {
         margin: 0;
         position: absolute;
         top: 50%;
         -ms-transform: translateY(-50%);
         transform: translateY(-50%);
      }


      .vertical-center-with-title {
         margin: 0;
         position: absolute;
         top: 60%;
         -ms-transform: translateY(-50%);
         transform: translateY(-50%);
      }


      /* For progress bar */
      .remark-slide-number {
        position: inherit;
      }

      .remark-slide-number .progress-bar-container {
        position: absolute;
        bottom: 0;
        height: 4px;
        display: block;
        left: 0;
        right: 0;
      }

      .remark-slide-number .progress-bar {
        height: 100%;
        background-color: #6a3d9a;
      }

    /* Header and Footer from
    https://github.com/gnab/remark/issues/501#issuecomment-392961900/
    */

    div.my-header {
      background-color: #7570b3;
      position: fixed;
      top: 0px;
      left: 0px;
      height: 10px;
      width: 100%;
      text-align: left;
    }

    div.my-footer img {
      height: 75px;
      width: 75px;
      bottom: 5px;
      right: 5px;
      position: fixed;
    }

  /* Comment  */
  .remark-slide-content {
    font-size: 20px;

  }


    </style>
  </head>
  <body>
    <textarea id="source" bar>

layout: true
<div class="my-header"></div>
   <div class="my-footer"><img src="../_images/BareBonesBash_Icon.png" /></div>


---

class: center, middle

# .tiny[_Boosted_ Bespoke]
# .large[**Bare Bones Bash**]
## .tiny[Brought By Blissfully Baffled Bioinformaticians]

Thiseas C. Lamnidis

James A. Fellows Yates

Aida Andrades Valtueña
<br/>
<br/>
<br/>

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
  <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
</a>
.small[<br />This work is licensed under a <br/> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.]

---

# Who are we?

.small[### Thiseas]
.medium[
- BSc. @ Department of Biology (York)
- MSc. @ Department of Anthropology (Durham)
- Ph.D.(?) @ Department of Archaeogenetics (Jena)
]

.small[
### James]
.medium[
- BSc. @ Department of Archaeology (York)
- MSc. @ Institute for Archaeological Sciences (Tübingen)
- Ph.D.(?) @ Department of Archaeogenetics (Jena)
]

.small[### Aida]
.medium[
- BSc. @ Department of Genetics, UAB (Barcelona)
- MSc. @ Institute for Archaeological Sciences (Tübingen)
- Ph.D.(?) @ Department of Archaeogenetics (Jena)
]

.right-column-33[
<div class="vertical-center-with-title">
  <img src=".images/bbb_all.svg" width="80%">
</div>
]

???
BOTH

---

# Aims of this session


- Aim:

  - Get more familiar with text modification with bash

--

- Objectives:
  - How to find stuff?
  - What is a while loop?
  - How to write a conditional statement (if/else)
  - Regular expressions (aka "Regex")
  - How to write a simple bash script
  - _Simple_ text modfication with `sed` (i.e. witchcraft)

--

.left-column[
<p align="center">
  <img title="Source https://giphy.com/gifs/comedy-retro-musical-UjYw9fdCEPwU8" src="https://media.giphy.com/media/UjYw9fdCEPwU8/giphy.gif" width=55% >
</p>
]

--

.right-column[
<p align="center">
  <img title="Source: https://giphy.com/gifs/bethesda-elder-scrolls-online-necromancer-zumog-phoom-hsaHwzGKJucbXRa7B6" src="https://media.giphy.com/media/hsaHwzGKJucbXRa7B6/giphy.gif" width=70% >
</p>
]

---

class: center, middle

# **RECAP**: Five Commandments of Bare Bones Bash

???
THISEAS

---

class: middle

.left-column[
### 1. Be lazy! <br><br><br><br><br><br><br><br><br><br><br><br><br><br>
]

.right-column[
- Desire for shortcuts motivates you to explore more!
]

???
It's better to spend 1day working on a script that will save you 5min per day for the rest of your PhD, than putting in those 5 minutes!

TAB will be you favourite key by the time we are done here.

---

class: middle
.left-column[
### 1. Be lazy!
### 2. ~~Google~~ The Hive-Mind knows everything.<br><br><br><br><br><br><br><br><br><br><br><br><br>
]

.right-column[
- Desire for shortcuts motivates you to explore more!<br><br><br>

- 99% of the time, someone else has already had the same issue.

]
???
HOW to google programming questions is not as trivial as it sounds. In the final part of today's session we can talk a bit about this.

---

class: middle
.left-column[
### 1. Be lazy!
### 2. ~~Google~~ The Hive-Mind knows everything.
### 3. Document everything you do.<br><br><br><br><br><br><br><br><br><br><br><br>
]

.right-column[
- Desire for shortcuts motivates you to explore more!<br><br><br>

- 99% of the time, someone else has already had the same issue.<br><br><br><br>

- Make future you happy
]

---

class: middle

.left-column[
### 1. Be lazy!
### 2. ~~Google~~ The Hive-Mind knows everything.
### 3. Document everything you do.
### 4. There will ALWAYS be a typo!<br><br><br><br><br><br><br><br><br><br><br>
]
.right-column[
- Desire for shortcuts motivates you to explore more!<br><br><br>

- 99% of the time, someone else has already had the same issue.<br><br><br><br>

- Make future you happy<br><br><br><br>

- Don't get disheartened, even best programmers make mistakes

]

---

class: middle

.left-column[
### 1. Be lazy!
### 2. ~~Google~~ The Hive-Mind knows everything.
### 3. Document everything you do.
### 4. There will ALWAYS be a typo!
### 5. Don't be afraid of you freedom!<br><br><br><br><br><br><br><br><br><br>

]

.right-column[
- Desire for shortcuts motivates you to explore more!<br><br><br>

- 99% of the time, someone else has already had the same issue.<br><br><br><br>

- Make future you happy<br><br><br><br>

- Don't get disheartened, even best programmers make mistakes<br><br><br><br>

- Explore! Try out things!
]

???
In my experience, most of learning in programming happens by failing. Repeatedly!

---

class: center middle

# Preparation!

---
exclude: true
# Materials

- A long-form walkthrough, and these slides, are all freely avaliable avaliable at:
[https://barebonesbash.github.io/](https://barebonesbash.github.io/#/bbb2/README)

Under the 'Boosted' section.

<center>
**INSERT BOOSTED BBB TOC SCREENSHOT HERE**
</center>

---

# Into the hacker-verse

>  ⚠️This section is only for when we are giving the presentation in person! Otherwise, log onto your own unix local PC or server and jump [here](#mind-the)

- Connecting to our server
  - In your browser, go to the URL that you got with your login information.
  - Log-in with the user and password we provided you.

---

class: center

<p align="left"><img src=".images/Jupyter1.png" width="100%" ></p>

---

class: center

<p align="left"><img src=".images/Jupyter2.png" width="100%" ></p>

---

class: center

<p align="left"><img src=".images/Jupyter3.png" width="100%" ></p>

---

class: center

<p align="left"><img src=".images/Jupyter4.png" width="100%" ></p>

---

class: center

<p align="left"><img src=".images/Jupyter5.png" width="100%" ></p>

???
What you see here is the "command prompt". username@server:pwd$
me, at the workshop server. ~ means "my HOME directory" (user specific).

---

name: mind-the

class: middle, center

# Always mind the `$` and `>`!

<p align="center">
  <img title="Source: https://giphy.com/gifs/studiosoriginals-gilphabet-3o84U72tKO389H2lI4" src="https://media.giphy.com/media/3o84U72tKO389H2lI4/giphy.gif" width = "54%">
  <img title="Source: https://giphy.com/gifs/animography-animated-typography-font-gzJNFeqcRcqnm" src="https://media.giphy.com/media/gzJNFeqcRcqnm/giphy.gif" width="30%">
</p>

**Tip** When _sharing_ code, don't include the `$` or `>` from your command prompt! makes it harder for others to run!

To write multi-line code in one: replace a newline with a `;`

???
in Bash ALWAYS MIND THE `$`! Only copy after the `$` so you dont paste the command prompt too. `$` is also important when dealing with variables, which you saw a bit last time and will see more of today.

In this presentation we will use `$` at the start of a line of code to show where the command prompt would be.

We will use `>` to denote the subsequent lines of a multi-line code command.

---

class: center,middle

# Uhh... what did we do??

## ([Last time](https://barebonesbash.github.io/#/bbb1/README))

<p align="center">
  <img title="Source: https://giphy.com/gifs/sonic-the-hedgehog-PJiqz1RHkdtGE" src="https://media.giphy.com/media/PJiqz1RHkdtGE/giphy.gif" >
</p>

---

# Uhh... what did we do?

- **Make** a directory:

---
# Uhh... what did we do?


- ~~**Make** a directory:~~

- **What** did that do again?

```bash
$ whatis mkdir
## or
$ man mkdir

```

---

# Uhh... what did we do?

- **Make** a directory:

.left-column[
```bash
$ mkdir boosted_barebonesbash
```
]

.right-column[
> **Tip:** You can specify multiple directories in one command!
]

???
Some people in homework had one `mkdir` command for each directory they made, this isn't necessary! You can specify multiple new names after `mkdir` and each one will be created for you.

--

- How to **download** a file?

```bash
$ wget git.io/Boosted-BBB-meta
```
> Tip: If using a mac use 'curl -LO' instead!


--

- How to **move** a something e.g. file into a directory?

```bash
$ mv Boosted-BBB-meta  boosted_barebonesbash/Boosted-BBB-meta.tsv
```
> `mv` can both move and rename! It even does these simultaneously!

---

# Uhh... what did we do?

- **Make** a directory:

.left-column[
```bash
$ mkdir boosted_barebonesbash
```
]

.right-column[
> **Tip:** You can specify multiple directories in one command!
]

- How to **download** a file?

```bash
$ wget git.io/Boosted-BBB-meta
```
> Tip: If using a mac use 'curl -LO' instead!

- How to **move** a something e.g. file into a directory?

```bash
$ mv Boosted-BBB-meta  boosted_barebonesbash/Boosted-BBB-meta.tsv
```

.left-column[
- Change **into** a directory

```bash
$ cd boosted_barebonesbash

```

]
--
.right-column[
- What's **inside** my directory (+ info)?

```bash
$ ls -l

```

]


---

# Uhh... what did we do?

- What's **inside** a (text) file?

```bash
$ cat Boosted-BBB-meta.tsv
$ head Boosted-BBB-meta.tsv
$ tail Boosted-BBB-meta.tsv
$ less Boosted-BBB-meta.tsv

```
???
Remeber, `less` opens a viewer window. exit that by pressing `q`

--

- How to **combine** tools?
- How to **search inside** a text file?

```bash
$ cat Boosted-BBB-meta.tsv | grep 'fanta' | wc -l

```
???
Combine tools with `|`. You will learn a bit more about how that works today.

`grep` will look for lines containing the string `'fanta'`.
--

> Tip: Be _lazy_; No need for `cat`!

```bash
$ grep 'fanta' Boosted-BBB-meta.tsv | wc -l

```


???
Remember we want to be lazy and efficient. While it is sometimes more 'readable', you don't need to cat every file into every program. Almost all programs accept a file by default.

The latter means 1) less typing and 2) less computational resources

--

- How do I **edit** a file?

```bash
$ nano Boosted-BBB-meta.tsv
```
> To exit without saving any changes: ctrl + x




---

# Uhh... what did we do?

- How to assign a **variable**

```bash
$ Variable=Yes
```

--

- How do I **repeat** a command multiple times on a list of things?

```bash
$ for i in Greece Spain Britain; do
>  echo "Does $i have lovely food? $Variable"
> done

```
--
```
Does Greece have lovely food? Yes
Does Spain have lovely food? Yes
Does Britain have lovely food? Yes

```

---

# Preparation


- Download the following file

```bash
$ <whats_the_command?> git.io/Boosted-BBB-images
```

---

# Preparation

- Download the following file

```bash
## use wget to download a file because it's _cooler_
$ wget git.io/Boosted-BBB-images
```
>Tip: write _why_ and _what_ you are doing in a comment with `#`

???

Also: COMMENTING IS LANGUAGE SPECIFIC. In bash you can only use #.

i.e. Nicely written code should be self explanatory as to 'how', but 'why' is more useful.

--

- `unzip` the `.zip` file by **auto-completing the file name with your TAB key!**

```bash
$ unzip Boosted-BBB-images
```
> **Protip**: Clear your terminal of old lines with <kbd>ctrl</kbd> + <kbd>l</kbd>


--

.left-column[
> * What is the name of the extracted directory?
> * What do you see in there?

- To remove unwanted files
```bash
$ rm Boosted-BBB-images
```

]

.right-column[
<p align="center">
  <img title="Source: https://giphy.com/gifs/bobs-burgers-fox-bobs-burgers-3og0IRc1sW8yPON3WM" src="https://media.giphy.com/media/3og0IRc1sW8yPON3WM/giphy.gif" width="80%">
</p>
]

---

# Final Tips

.left-column[
<p align="center">
  <img title="https://giphy.com/gifs/UKTVGIFBANK-eMUEeNGdwU7JDZ28g0" src="https://media.giphy.com/media/eMUEeNGdwU7JDZ28g0/giphy.gif" width="80%">
</p>
]

.left-column[

- **Symlinks**: ALWAYS include a 'target' directory when using `ln -s` (even if just `.`).
  - This is more readable, and less error prone!

- **grep**: to select all lines _not_ matching a pattern, can use the grep flag `-v` (no need to `diff`!)

- Comments
  - Comment **step by step**!
  - Better: **why** something is done, rather than _what_ it accomplishes.
  - Helps others (such as your baffled bioinformaticians) and **yourself** in two years.

]

???

Based on common issues with 'homeworks' from in-person sessions of BBB

---

class: middle,center

<p align="center">
  <img title="Source: https://giphy.com/gifs/mario-super-64-WZdlab0U3AkSc
" src="https://media.giphy.com/media/WZdlab0U3AkSc/giphy.gif">
</p>

Make sure to `cd` back to `~/boosted_barebonesbash` now!

???

OK! Recap done! LETS'A GO!

---

#Outline

.large[
- Where is my stuff??
- Concept: Datastreams and redirects
- Concept: Quotes matter!
- How to rename stuff
- Concept: Bash expansion
- Concept: Regular expressions
- While loop: to infinity and beyond!
- Conditionals: IF/ELSE
- Modifying files: SED, PASTE
]

---

# Where is my stuff??

```bash
$ find # Don't run yet!
```

How can you search for files and directories hidden in layers and layers
(of your very organised 😉) directories?

<p align="center">
  <img title="https://giphy.com/gifs/download-find-funsubstancea-XSJIE5xMWA9HO
" src="https://media.giphy.com/media/XSJIE5xMWA9HO/giphy.gif">
</p>

---

# Where is my stuff??
```bash
$ find Boosted-BBB/  # Don't run yet!
```
- **First** part of the `find` command: _the place to look from_

  - e.g. `.` to indicate 'here'
--

  - Could also use `~/`
--

  - Could use absolute path e.g. `/home/james/`

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

> **Question** What is the difference between `Boosted-BBB/` and `/home/james/boosted_barebonesbash/Boosted-BBB/`?

---

# Where is my stuff??
```bash
$ find Boosted-BBB/ -type f # Don't run yet!
```
- **First** part of the `find` command: _the place to look from_
  - e.g. `.` to indicate 'here'
  - Could also use `~/`
  - Could use absolute path e.g. `/home/james/`

- **Second** part of the `find` command: _what type of things to look for?_
  - Use `-type` to define the filetype:
     - __f__ile
     - __d__irectory


---

# Where is my stuff??
```bash
$ find Boosted-BBB/ -type f -name '*JPG*'  # Don't run yet!
```
- **First** part of the `find` command: _the place to look from_
  - e.g. `.` to indicate 'here'
  - Could also use `~/`
  - Could use absolute path e.g. `/home/james/`

- **Second** part of the `find` command: _what type of things to look for?_
  - Use `-type` to define the filetype:
     - __f__ile
     - __d__irectory

- **Third** part of the `find` command: _what to look in_?
  - Use `-name` to say 'look in _names_ of things'

<br/>
<br/>

---

# Where is my stuff??
```bash
$ find Boosted-BBB/ -type f -name '*JPG*'  # Now GO!
```
- **First** part of the `find` command: _the place to look from_
  - e.g. `.` to indicate 'here'
  - Could also use `~/`
  - Could use absolute path e.g. `/home/james/`

- **Second** part of the `find` command: _what type of things to look for?_
  - Use `-type` to define the filetype:
     - __f__ile
     - __d__irectory

- **Third** part of the `find` command: _what to look in_?
  - Use `-name` to say 'look in _names_ of things'

- **Finally** after `-name` we give the the 'strings' to search for
  - Use wildcards (`*`) for maximum laziness!

---
# Where is my stuff??

We are looking for all files with the suffix `JPG`.

Let's first set the suffix we want to a variable, so we can easily change it in the future.

```bash
$ suffix="JPG"
```
--

We can now call on this variable in our search. Try the following command:

```bash
$ find Boosted-BBB/ -type f -name '*$suffix*'
```
--
**That found no files!!** Our original `find` command confirms that these files exist!

--

.left-column-66[
Now look at the command below:

```bash
$ find Boosted-BBB/ -type f -name "*$suffix*"
```

What has changed here? Run the second command.
]
???
This time the command finds the files! What in 'tarnation is going on!?

---

# Where is my stuff??

We are looking for all files with the suffix `JPG`.

Let's first set the suffix we want to a variable, so we can easily change it in the future.

```bash
$ suffix="JPG"
```

We can now call on this variable in our search. Try the following command:

```bash
$ find Boosted-BBB/ -type f -name '*$suffix*'
```

**That found no files!!** Our original `find` command confirms that these files exist!
.left-column-66[
Now look at the command below:
```bash
$ find Boosted-BBB/ -type f -name "*$suffix*"
```
What has changed here? Run the second command.]

.right-column-33[
<p align="center"><img src="https://tenor.com/view/nagato-naruto-shippuden-nagato-kid-nani-apa-gif-12417317.gif" title="Source: https://tenor.com/view/nagato-naruto-shippuden-nagato-kid-nani-apa-gif-12417317.gif" width="70%">
</p>
]

???
This time the command finds the files! What in tarnation is going on!?

---

# Concept: Quotes matter!

In bash, there is a big difference between a single quote `'` and a double quote `"`!

 - The contents of single quotes, are passed on as they are.
 - Inside double quotes, contents are _interpreted_!

???
That means that it will be read just like the rest of the code.

--

.left-column-66[
In some cases the difference doesn't matter:
```bash
$ echo "I like Greek Food"
$ echo 'I like Greek Food'
```
```
I like Greek Food
I like Greek Food
```
]

--
.right-column-33[
      <p align="center"><img src="https://media.giphy.com/media/NSqQkXJjnsVpZQezfg/giphy.gif" title="Source: https://media.giphy.com/media/NSqQkXJjnsVpZQezfg/" width="90%">
      </p>
      <p align="center"><img src="https://media.giphy.com/media/bh4jzePjmd9iE/giphy.gif" title="Source: https://media.giphy.com/media/bh4jzePjmd9iE/" width="90%">
      </p>
]

.left-column-66[
In other cases it makes all the difference:
```bash
$ Arr=Banana
$ echo 'Pirates say $Arr'
$ echo "Minions say $Arr"
```
```
Pirates say $Arr
Minions say Banana
```
]

???
You can already see from the syntax highlighting that $Arr is treated differently in the two quotes.

---

# Cleaning up the filenames

It seems that wherever the files are from have completely mangled the file names (`.JPG.MP3.TXT`... WHAT?!)

Lets clean up the filenames, and then we can sort the files into categories.

--

**We first show an example that uses `cut` and `rev`.**

Any guesses what these commands might do?

  - `rev`:
  - `cut`:

???
Reward to anyone who uses `whatis` or `man`

---

# Cleaning up the filenames

It seems that wherever the files are from have completely mangled the file names (`.JPG.MP3.TXT`... WHAT?!)

Lets clean up the filenames, and then we can sort the files into categories.

**We first show an example that uses `cut` and `rev`.**

Any guesses what these commands might do?

  - `rev`: reverses a character string
  - `cut`: cuts a string into multiple pieces

.left-column[
<p align="center">
  <img style="transform: scaleX(-1)" src="https://media.giphy.com/media/mUGRVgAkamLZe/giphy.gif" title="Source: https://giphy.com/gifs/pony-mUGRVgAkamLZe" width="90%">
</p>
]

.right-column[
<p align="center">
  <img style="transform: scaleX(-1)" src="https://media.giphy.com/media/2GdACZsbRnTmo/giphy.gif" title="Source: https://giphy.com/gifs/movie-photoset-2GdACZsbRnTmo" width="83%">
</p>
]

???

Reward to anyone who uses `whatis` or `man`

---

# Cleaning up filenames

Let's try this out!

```bash
$ echo "aBcDeF 654321" | rev
```
```
123456 FeDcBa
```

--
`cut` needs some arguments.
 - `-d` specifies the field **d**elimiter we are using. Here it is space (`" "`).
 - `-f` specifies which **f**ield we wish to cut out (the second one).

```bash
$ echo "aBcDeF 654321" | cut -d " " -f 2
```
```
654321
```

---

# Cleaning up filenames

Using these tools, we can start cleaning up the desired filenames like this:

```bash
$ for file in $(find Boosted-BBB/ -type f -name "*JPG*"); do
>   new_name=$(echo $file | rev | cut -d "." -f 2-999 | rev)
>   echo $file $new_name
>   #mv $file $new_name
> done
```
Use `echo` to make a 'dry-run', and when you're happy with the proposed output
uncomment the `mv` command and re-run the `for` loop.

--

**BUT WAIT! This code is cumbersome to write, read and understand.**
<p align="center"><img src="https://tenor.com/view/what-confused-ugh-blackadder-rowan-atkinson-gif-11050590.gif" title="Source: https://tenor.com/view/what-confused-ugh-blackadder-rowan-atkinson-gif-11050590.gif" width="40%">
</p>
???
So let's take a step-by-step look at what just happened.

---

# Wait, what just happened?

`$()` tells bash to run the commands within parentheses and interpret the output as a string, which is then assigned to the variable `new_name`

--

#####We start out with a filepath:
```
~/boosted_barebonesbash/Boosted-BBB/Friday/night/and/the/lights/are/low/fanta.JPG.MP3.TXT
```

--

#####We `rev`erse the filename:
```
TXT.3PM.GPJ.atnaf/wol/era/sthgil/eht/dna/thgin/yadirF/BBB-detsooB/hsabsenoberab_detsoob/~
```

--

#####We `cut` the string at each `-d`elimiter (`.`), and keep everything after the first delimiter (`-f`ields `2-999`):
```
    3PM.GPJ.atnaf/wol/era/sthgil/eht/dna/thgin/yadirF/BBB-detsooB/hsabsenoberab_detsoob/~
```
--

#####We `rev`erse what is left back to its original orientation:
```
~/boosted_barebonesbash/Boosted-BBB/Friday/night/and/the/lights/are/low/fanta.JPG.MP3
```
--

#####We then rename the file to the new filename with `mv`.


---
# Writing pretty code

It is a good idea to avoid clunky code like what you just saw.

How to make this code simpler? **Do not run this code!**

```bash
$ for file in $(find Boosted-BBB/ -type f -name "*JPG*"); do
>   new_name=$(echo $file | rev | cut -d "." -f 2-999 | rev)
>   echo $file $new_name
>   # mv $file $new_name
> done
```

--
We can make it shorter and better with **parameter expansion** (the magic).
???
Remember how we were saying a variable is like a box that you can put anything inside? Imagine being sent baking ingredients in the mail, and making a strudel out of the ingredients as you open the package!
--

<p align="center"><img src="https://tenor.com/view/fantastic-beasts-fantastic-beasts-and-where-to-find-them-strudel-magic-food-gif-7865320.gif" title="Source: https://tenor.com/view/fantastic-beasts-fantastic-beasts-and-where-to-find-them-strudel-magic-food-gif-7865320.gif" width="50%">
</p>

---

# The basics

Here's an example variable:
```bash
$ foo="/home/thiseas/folder/subfolder/BBB.is.bae.txt"
```
???
The absolute file path to some imaginary file.

--

.left-column[

To expand a variable use `${}`.
```bash
$ echo ${foo}
```
```
/home/thiseas/folder/subfolder/BBB.is.bae.txt
```
]

.right-column[
<p align="center"><img src="https://media.giphy.com/media/8YpifFDs9Ux1VNQP1S/giphy.gif" title="Source: https://giphy.com/gifs/adweek-color-apple-8YpifFDs9Ux1VNQP1S/links" width="75%">
</p>
]

???
This is actually what bash did behind-the-scenes when we typed `$Var` thus far.
It is a good idea to put all variables in `{}` so there is never any confusion as to which is the variable name.

--

You can also add a **parameter** to expansions:
```bash
$ echo ${foo#/home/}
$ echo ${foo#*/}
```
```
thiseas/folder/subfolder/BBB.is.bae.txt
home/thiseas/folder/subfolder/BBB.is.bae.txt

```
???
The first command strips the text after the # from the START of the variable.

You can also use wildcards to make more general expansions.

---

# Some parameters for expansion

```bash
$ foo="/home/thiseas/folder/subfolder/BBB.is.bae.txt"
$ echo ${foo}    # No parameters in this expansion
$ echo ${foo#*/} # Removes everything before the first '/'
$ echo ${foo%.*} # What will this do?
```
--
```
/home/thiseas/folder/subfolder/BBB.is.bae.txt
 home/thiseas/folder/subfolder/BBB.is.bae.txt
/home/thiseas/folder/subfolder/BBB.is.bae
```
???
Bash will look for the provided pattern ONCE and remove it.

There are more `.` and `/` but they are not removed.
--

These expansion can be generalised:
```bash
$ echo ${foo##*/} # Removes everything before any '/'
$ echo ${foo%%.*} # Removes everything after any '.'
```
--
```
BBB.is.bae.txt
/home/thiseas/folder/subfolder/BBB
```
???
When the parameter is given twice, bash will keep searching for the pattern until it can no longer find it.

---
# More parameters for expansion

You can use two `/` to substitute parts of the variable:
```bash
$ foo="/home/thiseas/folder/subfolder/BBB.is.bae.txt"
$ echo ${foo}                    # No parameters
$ echo ${foo/BBB/BareBonesBash}  # Change BBB to BareBonesBash
```
```
/home/thiseas/folder/subfolder/BBB.is.bae.txt
/home/thiseas/folder/subfolder/BareBonesBash.is.bae.txt
```
--

<p align="center"><img src="https://media.giphy.com/media/b7sNm0aR2EOqI/giphy.gif" title="Source: https://giphy.com/gifs/teachers-b7sNm0aR2EOqI" width="30%">
</p>

---

# More parameters for expansion

You can use two `/` to substitute parts of the variable:
```bash
$ foo="/home/thiseas/folder/subfolder/BBB.is.bae.txt"
$ echo ${foo}                    # No parameters
$ echo ${foo/BBB/BareBonesBash}  # Change BBB to BareBonesBash
```
```
/home/thiseas/folder/subfolder/BBB.is.bae.txt
/home/thiseas/folder/subfolder/BareBonesBash.is.bae.txt
```

Leaving the second `/` out replaces the pattern with "an empty string".
```bash
$ echo ${foo/BBB}  # Remove BBB
```
???
That is programmer speak for "nothing". i.e. it removes the pattern.
--
```
/home/thiseas/folder/subfolder/.is.bae.txt
```

---
# The last parameter, I swear!

Finally, you can check the length of a variable by using a `#` BEFORE the variable name.
```bash
$ foo="/home/thiseas/folder/subfolder/BBB.is.bae.txt"
$ echo ${#foo}  # The length of the variable contents
```
--
```
45
```
So the filepath in `foo` is 45 characters long!

--

This parameter is more useful when dealing with **bash arrays** (i.e. lists of things).
<p align="center">
  <img src="https://media.giphy.com/media/xUNd9DLukkavmhybAs/giphy.gif
" title="Source: https://media.giphy.com/media/xUNd9DLukkavmhybAs/giphy.gif
" width="40%">
</p>

???
We will not be talking about bash arrays further, but they are basically indexed/numbered lists of stuff.

That means you can, for example, ask for the 5th item in a bash array and get only that one. Look em up if that sounds useful to you! **[Rule 2]**

---
# Writing pretty code
We can now rewrite this code. **DO NOT RUN THIS CODE!**
```bash
$ for file in $(find Boosted-BBB/ -type f -name "*JPG*"); do
>   new_name=$(echo $file | rev | cut -d "." -f 2-999 | rev)
>   echo $file $new_name
>   # mv $file $new_name
> done
```

To this:

```bash
$ for file in $(find Boosted-BBB/ -type f -name "*JPG*"); do
>   echo ${file} ${file%.*}
>   # mv ${file} ${file%.*}
> done
```

Try dry-running both and check the result is the same! Is there a difference in runtime? 

???
Note that Rev/cut is still useful in languages, Bash expansion is for bash!

--

.left-column-66[
Result: **0.051s** versus **0.003s** when running echo!
]

.right-column-33[
<p align="center">
  <img src="https://media.giphy.com/media/S9v6L1tFHk0pptZzCh/giphy.gif" title="Source: https://giphy.com/gifs/stickergiant-fast-zoom-on-my-way-S9v6L1tFHk0pptZzCh/links" width="50%">
</p>
]
--
Now you can run the second code block without commenting out `mv`.

???
Notice that this time around, I added ".JPG" at the end of the new filenames manually, since our approach removes it.
This code should run faster, especially when dealing with many more files!

It is much more efficient since parameter expansion is one command, instead of 4 commands strung together.

--

When sure it works, remove the comment to rename!

---

# Almost done!
We now have all the files named similarly, but some things are still a bit off. The file suffix `JPG` is conventionally written in lowercase characters (`jpg`).

Let's change all filename suffixes to be in lowercase letters!


<p align="center">
  <img src="https://media.giphy.com/media/l3diMwu8XYh6sa6VG/giphy.gif" title="Source: https://giphy.com/gifs/laffmobbslafftracks-laff-mobbs-tracks-episode-108-l3diMwu8XYh6sa6VG" width="30%">
</p>

--

Can be done with parameter expansion, but we can use **reg**ular **ex**pressions to do this without a for loop.

???
Remember, a string is fancy computer lingo for a sequence of characters and/or numbers. i.e. text

--

 - Regex is an important concept. You will find them in most programming languages.

 - Syntax can vary from language to language, but here's how they work in bash.


---

# Concept: Regular expressions
- Special strings and characters that define a 'search pattern'
- Used in 'Search' or 'Search/Replace' functions e.g. in excel!
- You have already used them!

--

To prepare, download the following file

```bash
$ wget git.io/Boosted-BBB-regex
$ mv Boosted-BBB-regex regex.txt
```
???
As usual, Mac users should use `curl -LO`

--

Let's also look at the contents.

```bash
cat regex.txt
```

???
Technically, all the wildcards you have used are regex!

---
# Regex Basics

.left-column-66[

Three regex special character 'categories' 
]

--

.left-column-66[
- `.`, `*`, `^`, `$` (etc.): special characters that are translated to regex function **first** ('escaped' with `\` to find the literal symbol) 
]

--

.left-column-66[
- `\t`, `\w`, `\D` (etc.): **letter-based** special characters that must have `\` to be 'translated'  
]

--

.left-column-66[
- `[]`, `()`, (etc.): range, grouping, or 'capturing' matching regex within **brackets**  
]

---

# Regex Basics

.left-column-66[

Three regex special character 'categories'  

- `.`, `*`, `^`, `$` (etc.): special characters that are translated to regex function **first** ('escaped' with `\` to find the literal symbol) 

- `\t`, `\w`, `\D` (etc.): **letter-based** special characters that must have `\` to be 'translated'  

- `[]`, `()`, (etc.): range, grouping, or 'capturing' matching regex within **brackets**  

]

.right-column-33[
pear  
pier  
pir  
per  
par  
pur  
bear  
beer  
br  
ber  
be\*r  
rear  
]
???
When you `cat regex.txt`, you should see the following printed on your screen. 

---
# Regex Basics
.left-column-66[
```{bash}
grep '.ear' regex.txt
```

> Finds strings containing: any character + ear


- `.` : match any character

<p align="center">
  <img src="https://media.giphy.com/media/zlqDsYtuoyR9e/giphy.gif" title="Source: https://media.giphy.com/media/zlqDsYtuoyR9e/giphy.gif" width="50%">
</p>

]
.right-column-33[
**pear**  
pier  
pir  
per  
par  
pur  
**bear**  
beer  
br  
ber  
be\*r  
**rear**  
]



---
# Regex Basics
.left-column-66[
```{bash}
grep 'p[iea]r' regex.txt
```

> String starting with p+ one of i or e or a +r

- `.` : match any character
- `[]`: match range of characters within []
]
.right-column-33[
pear  
pier  
**pir**  
**per**  
**par**  
pur  
bear  
beer  
br  
ber  
be\*r  
rear  
]

---
# Regex Basics
.left-column-66[
```{bash}
grep 'p[^iea]r' regex.txt
```

> String starting with p+ any character except i, e or a+r

- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
]
.right-column-33[
pear  
pier  
pir  
per  
par  
**pur**  
bear  
beer  
br  
ber  
be\*r  
rear  
]

---
# Regex Basics
.left-column-66[
```{bash}
grep 'be*r' regex.txt
```

> String that starts with b+ zero or multiple 'e' +r

- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items

<p align="center">
  <img src="https://media.giphy.com/media/Zw3oBUuOlDJ3W/giphy.gif" title="Source: https://giphy.com/gifs/beer-cheers-shaun-of-the-dead-Zw3oBUuOlDJ3W" width="50%">
</p>

]
.right-column-33[
pear  
pier  
pir  
per  
par  
pur  
bear  
**beer**  
**br**  
**ber**  
be\*r  
rear  
]

---
# Regex Basics
.left-column-66[
```{bash}
grep 'be\*r' regex.txt
```

> String 'be*r' 

- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: do not interpret next character
]
.right-column-33[
pear  
pier  
pir  
per  
par  
pur  
bear  
beer  
br  
ber  
**be\*r**  
rear  
]
???
Normally, `*` would be interpreted to `match 0 or more of the preceding items`. 

But because we have "escaped" interpretation with `\`, it is treated as an asterisk character (*).

---
# Regex Basics
.left-column-66[
```{bash}
grep 'be\+r' regex.txt
```

> String starting with b+ one or multiple 'e'+r

- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: do not interpret next character
- `\+`: match 1 or more of the preceding items

<p align="center">
  <img src="https://media.giphy.com/media/RqbkeCZGgipSo/giphy.gif" title="Source: https://giphy.com/gifs/dreaming-the-simpsons-RqbkeCZGgipSo" width="50%">
</p>

]
.right-column-33[
pear  
pier  
pir  
per  
par  
pur  
bear  
**beer**  
br  
**ber**  
be\*r  
rear  
]

---
# Regex Basics
.left-column-66[
```{bash}
grep 'be\?r' regex.txt
```

> String starting with b+ zero or one 'e'+r

- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: do not interpret next character
- `\+`: match 1 or more of the preceding items
- `\?`: match 0 or 1 of the preceding items
]
.right-column-33[
pear  
pier  
pir  
per  
par  
pur  
bear  
beer  
**br**  
**ber**  
be\*r  
rear  
]

---
# Regex Basics
.left-column-66[
```{bash}
grep '^[rb]\+' regex.txt
```

> Lines starting with one or multiple of: r or b 

- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: do not interpret next character
- `\+`: match 1 or more of the preceding items
- `\?`: match 0 or 1 of the preceding items
- `^`: the beginning of the line

<p align="center">
  <img src="https://media.giphy.com/media/J0ySNzZ5APILC/giphy.gif" title="Source: https://giphy.com/gifs/man-weekend-the-J0ySNzZ5APILC/links" width="50%">
</p>

]
.right-column-33[
pear  
pier  
pir  
per  
par  
pur  
**bear**  
**beer**  
**br**  
**ber**  
**be\*r**  
**rear**  
]

---
# Regex Basics
.left-column-66[
```{bash}
grep 'r$' regex.txt
```

> Lines ending with r

- `.` : match any character
- `[]`: match range of characters within []
- `[^]`: match range of characters except the ones in the bracket
- `*`: match 0 or more of the preceding items
- `\`: do not interpret next character
- `\+`: match 1 or more of the preceding items
- `\?`: match 0 or 1 of the preceding items
- `^`: the beginning of the line
- `$`: the end of the line

> This can be intimidating, however there are lots of resources on the internet
> (reminder: Google _everything_!) to help, such as: [https://regex101.com/](https://regex101.com/).
> Note that regex's can be slightly different per shell and language!

]
.right-column-33[
**pear**  
**pier**  
**pir**  
**per**  
**par**  
**pur**  
**bear**  
**beer**  
**br**  
**ber**  
**be\*r**  
**rear**  
]

???
https://www.rexegg.com/regex-quickstart.html: website describing regex characters and its variations with different languages

---
# Regex example
```
fanta.JPG
BydgoszczForest.JPG
snore.JPG
Bubobubo.JPG
giacomo.JPG
netsukeJapan.JPG
nomnom.JPG
pompeii.JPG
AlopochenaegyptiacaArnhem.JPG
exhibitRoyal.JPG
stretch.JPG
weimanarer.JPG
excited.JPG
licorne.JPG
angry.JPG
```
Which Regex would you use to find all the files ending with .JPG??
--

```bash
$ find Boosted-BBB/ -type f -name '*.JPG'
```

???
So if we want to match a specific set of characters, that always follow a `.` and precede the end of the line, which regex characters do we need?

---
# `rename`

`rename` lets you apply a regex to the name of files to rename them.

To convert all suffixes in the directory to lowercase characters:
```bash
$ find Boosted-BBB/ -type f -name '*.JPG' | rename 's/\.JPG$/.jpg/'
```

> Check with `find` whether the names are now as you expect!

???
By default, Macs do NOT have `rename` installed.

--

.left-column[

No `for` loop needed (yay for pipes!)!

The expression given to `rename` has three parts, separated by `/`
]

.right-column[
<p align="center">
  <img src="https://media1.tenor.com/images/16669249a63fd292abcdd549a33b1333/tenor.gif?itemid=10650902" title="Source: https://tenor.com/view/friends-phoebe-gif-10650902" width="50%">
</p>

]

 - First, we define we want to **s**ubstitute the regex matches for another string

--

 - Second, we define the regex to query. `\.JPG$`

???
Why do we need the `\` before the `.`?

To interpret the `.` as a literal `.` and not "any character"

--

> Remember: to _escape_ a character (so read as an actual character, not as a regex), use `\` before it

 - Finally, we specify what we want to substitute matches with, which is `.jpg`

???
The substitute string is NOT a regex, so we do not need to escape the `.`

Optionally you can specify option after the final `/`. For e.g. putting a `j` there will lookfor multiple matches in each line instead.

---
# Onwards!

Ok, so we can now use find to see all the new and pretty filepaths:
```bash
$ suffix="jpg"
$ find Boosted-BBB/ -type f -name "*${suffix}"
```
<p align="center">
  <img src="https://media.giphy.com/media/yJFeycRK2DB4c/giphy.gif
" title="Source: https://media.giphy.com/media/yJFeycRK2DB4c/giphy.gif
" width="40%">
</p>
--

We can finally start sorting the pictures into categories!

To do that, we need to keep track of all the file names. We can easily gather this information using a **redirect**!

---
# Concept: Datastreams
Programs can take in and spit out data from different _streams_. By default there are 3 such data streams.

???
Before we talk about redirects, you need to understand datastreams.

--
.left-column[

- `stdin`: the __st__an__d__ard __in__put
- `stdout`: the __st__an__d__ard __out__put
- `stderr`: the __st__an__d__ard __err__or
]
???
stderr is what is usually printed on your screen, while stout is generally what ends up in output files, but it also goes to your screen by default.
--
.right.column[
<p align="center">
  <img src=".images/Datastreams.png" width="50%">
</p>]
???
In the background, each program also broadcasts an `exit code` which tells you if the program encountered errors. You will never see these in the wild, but it's good to know they exist.
--

.left-column[
<br><br><br>___A program is like the human body; One way in, two ways out!___
]
.right-column[<p align="center"><img src="https://media.giphy.com/media/4kg8IIClzvLtC/giphy.gif" title="Source: https://media.giphy.com/media/4kg8IIClzvLtC/" width="40%">
</p>]
???
In this analogy exit codes would be how the person is _feeling_, I suppose.

---
# Pipes revisited
In the first session you learned about piping. Here's how that works!
<br>
<br>
--

<p>
  <img src=".images/Piping.png" width="100%">
</p>
<br>
<br>
The `stdout` of one script becomes the `stdin` of the other.
`stderr` is printed on your screen.

---
# Concept: Redirects

Much like streams in the real world, datastreams can be redirected.

???
This way you can save the stdout of a program (or even the stderr) into a file to save for later.

--

- `stdin` can be redirected with `<`.

???
An arrow pointing TO your program name!

--

- `stdout` can be redirected with `>`.

???
An arrow pointing AWAY your program name!

--

- `stderr` can be redirected with `2>`.

???
Because it is the secondary output stream.

--

It is also possible to combine streams, but we won't get into that here.
<p align="center"><img src="https://media.giphy.com/media/3o72EWUgbRNfLegO1W/giphy.gif" title="Source: https://media.giphy.com/media/3o72EWUgbRNfLegO1W/" width="80%">
</p>

---

# Let's redirect!

We can get a list of all the file names by redirecting the `stdout` of the `find` command.

```bash
$ suffix="jpg"
$ find Boosted-BBB/ -type f -name "*${suffix}" > File_names.txt
```

--

This time, nothing was printed on your screen, because you redirected that output into a file.

You can `cat` the resulting file to see that everything worked.

<p align="center"><img src="https://media.giphy.com/media/JqDeI2yjpSRgdh35oe/giphy.gif" title="Source: https://media.giphy.com/media/JqDeI2yjpSRgdh35oe/" width="35%">
</p>

---

# Getting parts of a filepath

Before moving on, there are two useful commands you should know.

`basename` will tell you the file name, while stripping the path to the file.
```bash
$ basename data/Boosted-BBB//Having/the/time/of/your/life/bubobubo.JPG.MP3.TXT
```
```
bubobubo.JPG.MP3.TXT
```

--

`dirname` does the opposite. It will tell you the path to the directory that a file is in, while omitting the name of the file.
```bash
$ dirname data/Boosted-BBB//Having/the/time/of/your/life/bubobubo.JPG.MP3.TXT
```
```
data/Boosted-BBB//Having/the/time/of/your/life
```

---

# Reading from a file

Ok, so you now have a file with all the paths to the images we need. But the folder structure is still a mess. It's time to read the contents of the file with a `while` loop!

--

A `while` loop is a special type of repeating code that keeps going until it is interrupted.

--

We will also use `read`. This command takes the contents of the file and loads them into a specified variable.

<p align="center"><img src="https://media.giphy.com/media/WoWm8YzFQJg5i/source.gif" title="Source: https://giphy.com/gifs/cartoons-comics-sea-reading-WoWm8YzFQJg5i" width="35%">
</p>

---

# Reading from a file

Ok, so you now have a file with all the paths to the images we need. But the folder structure is still a mess. It's time to read the contents of the file with a `while` loop!

A `while` loop is a special type of repeating code that keeps going until it is interrupted.

We will also use `read`. This command takes the contents of the file and loads them into a specified variable.

```bash
$ mkdir images
$ while read filepath; do
>   echo "${filepath}" images/$(basename ${filepath})
>   # mv ${filepath} images/$(basename ${filepath})
> done < File_names.txt
```

When you're ready, uncomment the `mv` command to move each file from the
original location into the new location!

> Question: in this context, why do you have to use 'basename' for the target directory?

???
First, we make the directory `images`, then the `while` loop reads through the contents of each line in `File_names.txt`.

`read` puts the contents of the line in the variable `fname` and then the code in the loop is executed. 

With the redirect after `done` we give the while loop `File_names.txt` as input.

---

# Concept: While Loops

We have previously introduced the concept of a loop, and already used a few today.

**From Basic_BBB**

```bash
$ for file in file1 file2 file3 file4; do
>   echo "${file}"
> done
```

For loops repeat a set of code for a set of items, by changing the value of a variable in each iteration.

---

# Concept: While Loops

`For` loops are finite, they go through your list and stop when they run out of things.

Instead, a `while` loop keeps going until a statement is false.
```bash
$ while [statment]; do     #means while statement is true do
>   [whatever you want to do]
> done
```
--
An easy example:

.left-column[
```bash
$ n = 3
$ while n > 0; do
>   echo $n
>   n = $n - s1
> done
```
]
.right-column[
```
3
2
1
```
]

???
use while to move files out of the gifs horrible folder mess?

---
# Concept: While Loops
Didn't you say while loop are infinite?
.left-column[
```bash
$ n = 3
$ while n < 5; do
>   echo $n
>   n = $n - 1
> done
```
]
.right-column[
<p align="center"><img src="https://media.giphy.com/media/U2BASTIsaw8WQ/source.gif" title="Source: https://giphy.com/gifs/elevator-berlin-lift-U2BASTIsaw8WQ" width="90%">
</p>
]
--

- Always include a stop!
  - i.e. ensure your condition will eventually become 'false'!

--

.left-column-66[
Following our example from the beginning...

```bash
$ while read filepath; do
>   echo "${filepath}" images/$(basename ${filepath})
>   # mv ${filepath} images/$(basename ${filepath})
> done < File_names.txt
```
]

.right-column-33[
  ...the condition `read filepath` becomes false when there are no more lines in the file `File_names.txt` (i.e. '`EOF`')
]

???
Programmer lingo: `EOF` means end of file! 

---

# Pasting things side by side!

As you remember from the beginning, we downloaded a metadata file, which
includes different metadata categories for each file.

Lets look in the file!

```bash
$ cat Boosted-BBB-meta.tsv
```

???
You wanted to minimise the time you spend typing while on hunting for your best images, so you didn't type the category name, but codes A B C for each one.

--

Now we want to put together a list that states in which category each image was is a part of.

???
In the metadata file, you have the names of the images, and you have the categories of each too.

--

You can use `paste` to paste the two lists together, and save the results!

```bash
$ ls -1 images/* | paste - Boosted-BBB-meta.tsv # > Annotations.txt
```
???
`ls -1` forces the output into a single column. `paste` accepts the `stdin` and puts it at the position of `-`.
--
```
images/alopochenaegyptiacaArnhem.jpg	alopochenaegyptiacaArnhem	C	Funny
images/angry.jpg	angry	B	Artwork
images/bubobubo.jpg	bubobubo	C	Normal
...
images/snore.jpg	snore	B	Normal
images/stretch.jpg	stretch	B	Funny
images/weimanarer.jpg	weimanarer	A	Normal
```
???
Check that the file name matches the second column of each row. When u are satisfied, remove the `#` and save the output into `Annotations.txt`.

You now have a meta-data sheet for each jpg!

---

# Editing text with `sed`

To share these images with your internet friends, you need to properly specify the category names.

Let's add the actual category names to the `Annotations.txt`.

--

You can use `sed`, short for **s**tream **ed**itor, with a regex to edit the contents of a datastream on-the-fly.



```bash
$ sed 's/A/dog/' Annotations.txt
```

--
.left-column-33[
```
images/alopochenaegyptiacadogrnhem.jpg	alopochenaegyptiacaArnhem	C	Funny
images/angry.jpg	angry	B	dogrtwork
images/bubobubo.jpg	bubobubo	C	Normal
...
images/snore.jpg	snore	B	Normal
images/stretch.jpg	stretch	B	Funny
images/weimanarer.jpg	weimanarer	dog	Normal
```

**Uh-oh!**]
???
Do you see what went wrong? Don't worry, your file has not been changed in any way.
--
.right-column-66[
<p align="center"><img src="https://media.giphy.com/media/3ohzdYJK1wAdPWVk88/giphy.gif" title="Source: https://media.giphy.com/media/3ohzdYJK1wAdPWVk88/" width="40%">
</p>]

???
What happened here? How can we fix it?

Pattern matches the first A in a line with `dog`. We should make our regex more specific.
We know the value we want is a column, and hence it is surrounded by TABs! 
Change pattern to 's/\tA\t/\tdog\t/' to only match a single character column.

---

# Editing text with `sed`

```bash
$ sed 's/\tA\t/\tdog\t/' Annotations.txt
```
```
images/alopochenaegyptiacaArnhem.jpg	alopochenaegyptiacaArnhem	C	Funny
images/angry.jpg	angry	B	Artwork
images/bubobubo.jpg	bubobubo	C	Normal
...
images/snore.jpg	snore	B	Normal
images/stretch.jpg	stretch	B	Funny
images/weimanarer.jpg	weimanarer	dog	Normal
```
> On Macs, `sed` does not recognise `\t`.You will need to type in a tab character.

???
Much better!

Ensure your replacement also has tabs!
--

Use `-e` to provide multiple regular **e**xpressions to `sed`.
```bash
$ sed -e 's/\tA\t/\tdog\t/' -e 's/\tB\t/\tcat\t/' -e 's/\tC\t/\tbird\t/' Annotations.txt
```
???
Check the results for any errors.

--

When you are happy with the results, it is time to save the edits.

`sed` can edit a file **i**n place, with the `-i` option.
```bash
$ sed -i -e 's/\tA\t/\tdog\t/' -e 's/\tB\t/\tcat\t/' -e 's/\tC\t/\tbird\t/' Annotations.txt
```
???
On Mac, the `-i` option needs an argument so replace it with `-i ''`

---

# Cleanin' up my closet

.left-column-33[

Lets actually organise our into descriptive folders based our metadata file!

<p align="center">
  <img src="https://media.giphy.com/media/ZylxniYTM4rOfltszT/giphy.gif" title="Source: https://giphy.com/gifs/queen-the-show-must-go-on-ZylxniYTM4rOfltszT" width="60%">
</p>


For this, we need to use `conditionals`. This is a comparison of two things,
and if they are the same something happens, if different, something else happens.

The most basic conditional is an `if else` statement.
]

--

.right-column-66[

The basic syntax is like this

You can have sequential conditions too with `elif`, short for **el**se **if**.
```bash
$ if [[ ${my_variable} == "banana" ]]; then
>   echo "Monkey takes a banana and runs away happy."
> else
>   echo "Monkey doesn't want that."
> fi
```

You can have sequential conditions too with `elif`, short for **el**se **if**.

```bash
$ if [[ ${my_variable} == "banana" ]]; then
>   echo "Monkey takes a banana and runs away happy."
> elif [[ ${my_variable} == "mango" ]]; then
>   echo "Monkey takes a mango and eats it while staring at you."
> else
>   echo "Monkey doesn't want that."
> fi
```
]

???
Can you guess what would happen here depending on the contents of `my_variable`?

my_variable="banana"

my_variable="mango"

my_variable="pear"

---
# Conditions of conditionals

- `[[` behaves different to `[`. Usually, `[[` is what you want [_Long story, trust us._]

--

- You can evaluate mathematic equations with `((`

--

.left-column[
```bash
$ if (( 5 - 2 == 3)); then
>   echo "YES"
> fi
```
```
YES
```
]
---
# Conditions of conditionals

- `[[` behaves different to `[`. Usually, `[[` is what you want. [_Long story, trust us._]

- You can evaluate mathematic equations with `((`
- `!` can be used as a "not".

???
Turning a TRUE into FALSE and vice versa.

--

.left-column[
```bash
$ if (( 5 - 2 == 3)); then
>   echo "YES"
> fi
```
```
YES
```
]

.right-column[
```bash
$ if ! (( 5 - 2 == 3)); then
>   echo "YES"
> else
>   echo "NO"
> fi
```
```
NO
```
]

???

`!` can act as a "not" with square brackets as well.

---

# Conditions of conditionals

- Some options can be used to check if files exist, or is a variable has non-zero length.

--

```bash
$ if [[ -f Annotations.txt ]]; then
>   echo "File exists."
> fi

$ if [[ -n ${banana} ]]; then
>   echo "Variable is set."
> else
>   echo "Varable is NOT set."
> fi
```
```
File exists.
Varable is NOT set.
```

---

# Conditions of conditionals

- You can even combine multiple conditionals
  - `&&`: 'AND' - both must evaluate true 
  - `||`: 'OR' - at least one must evaluate true

--

```bash
LifeUniverseEverything=42
hitchhikers="awesome"
## AND
if [[ ${LifeUniverseEverything} == 42  && ${hitchhikers} == "awesome" ]]; then
  echo "Don't panic!"
fi
```
--
```bash
LifeUniverseEverything=41
hitchhikers="awesome"
## OR
if [[ ${LifeUniverseEverything} == 42  || ${hitchhikers} == "awesome" ]]; then
  echo "Still don't panic!"
fi
```

.left-column[
<p align="center"><img src="https://media.giphy.com/media/BVlWY2vMZgLG8/source.gif" title="Source: https://giphy.com/gifs/life-answer-42-BVlWY2vMZgLG8/" width="40%">
</p>
]

.right-column[
> Play around with the variables to get a feel!
]
---

## Sorting the images by category

We now want to create a directory for each category, and move images into each.

--

Let's add some conditionals! Before running, remember to try a _dry run_ with `echo`!

--

```bash
$ cd ~/boosted_barebonesbash/

## Parse the annotations file into variables
$ while read line; do
>   image_name=$(echo "${line}" | cut -f1)
>   animal=$(echo "${line}" | cut -f3)
> 
>   echo "${image_name}    ${animal}"
> 
> done < Annotations.txt
```
```
images/alopochenaegyptiacaArnhem.jpg    bird
images/angry.jpg    cat
images/bubobubo.jpg    bird
images/bydgoszczForest.jpg    bird
[...]
images/pompeii.jpg    dog
images/snore.jpg    cat
images/stretch.jpg    cat
images/weimanarer.jpg    dog
```

---

## Sorting the images by category

We now want to create a directory for each category, and move images into each.

Let's add some conditionals! Before running, remember to try a _dry run_ with `echo`!

```bash
$ cd ~/boosted_barebonesbash/

## Parse the annotations file into variables
$ while read line; do
>   image_name=$(echo "${line}" | cut -f1)
>   animal=$(echo "${line}" | cut -f3)
>  
>   # echo "${image_name}    ${animal}"
>  
>   ## Make a new directory for each animal, if one doesn't exist.
>   mkdir -p images/${animal}
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> done < Annotations.txt
```

---

## Sorting the images by category

We now want to create a directory for each category, and move images into each.

Let's add some conditionals! Before running, remember to try a _dry run_ with `echo`!

```bash
$ cd ~/boosted_barebonesbash/

## Parse the annotations file into variables
$ while read line; do
>   image_name=$(echo "${line}" | cut -f1)
>   animal=$(echo "${line}" | cut -f3)
> 
>   # echo "${image_name}    ${animal}"
> 
>   ## Make a new directory for each animal, if one doesn't exist.
>   mkdir -p images/${animal}
> 
>   ## If animal matches one of the three, move the image.
>   if [[ ${animal} == "cat" ]]; then
>     mv ${image_name} images/cat/
>   elif [[ ${animal} == "dog" ]]; then
>     mv ${image_name} images/dog/
>   elif [[ ${animal} == "bird" ]]; then
>     mv ${image_name} images/bird/
>   fi
> 
> done < Annotations.txt
```

---

# Housekeeping

Let's see if everything moved where we wanted.

```bash
$ find ~/boosted_barebonesbash/images/ -type f -name "*jpg"
```
--
```
/Users/lamnidis/boosted_barebonesbash/images//cat/snore.jpg
/Users/lamnidis/boosted_barebonesbash/images//cat/giacomo.jpg
/Users/lamnidis/boosted_barebonesbash/images//cat/excited.jpg
/Users/lamnidis/boosted_barebonesbash/images//cat/angry.jpg
/Users/lamnidis/boosted_barebonesbash/images//cat/stretch.jpg
/Users/lamnidis/boosted_barebonesbash/images//dog/licorne.jpg
/Users/lamnidis/boosted_barebonesbash/images//dog/fanta.jpg
/Users/lamnidis/boosted_barebonesbash/images//dog/weimanarer.jpg
/Users/lamnidis/boosted_barebonesbash/images//dog/pompeii.jpg
/Users/lamnidis/boosted_barebonesbash/images//dog/nomnom.jpg
/Users/lamnidis/boosted_barebonesbash/images//bird/alopochenaegyptiacaArnhem.jpg
/Users/lamnidis/boosted_barebonesbash/images//bird/bubobubo.jpg
/Users/lamnidis/boosted_barebonesbash/images//bird/netsukeJapan.jpg
/Users/lamnidis/boosted_barebonesbash/images//bird/bydgoszczForest.jpg
/Users/lamnidis/boosted_barebonesbash/images//bird/exhibitRoyal.jpg
```
Good! Everything moved into the correct subfolder!

---

# I have to do this every day!

We are already being lazy by getting the computer to loop through each file.

But what do you do if you have to do the same thing EVERYDAY? 

Do you really wanna write all the commands every time?!

<p align="center"><img src="https://media.giphy.com/media/iE4lKpKqwe7QIQCPjG/giphy.gif" title="Source: https://giphy.com/gifs/memecandy-iE4lKpKqwe7QIQCPjG" width="30%">
</p>

--

The ultimate goal of anyone working on the command line is to make a program which you can run with a single command and it does all the work for you.

That program is called a **_script_**.

---

# What's a script?

Similar to a play/movie script that tells actors what to do and the sequence in which they should do it, a computer script is a file containing all the commands that you want the computer to perform in a given order.


So let's start writing your first script `first_script.sh`! Open a text editor

```bash
$ nano first_script.sh
```

???

This will open a nano viewer window in your terminal.

--

<p align="center"><img src="https://media.giphy.com/media/26tn33aiTi1jkl6H6/giphy.gif" title="Source: https://media.giphy.com/media/26tn33aiTi1jkl6H6/" width="60%">
</p>


---

# Your first script!

The first thing you almost always need to do with any script is to specify which language the script is using. This is done with a 'shebang'

<p align="center"><img src="https://media.giphy.com/media/3o6Mbi2vzeke98ApAA/giphy.gif" title="Source: https://giphy.com/gifs/season-14-the-simpsons-14x5-3o6Mbi2vzeke98ApAA
" width="30%">
</p>

It consists of a `#!` to indicate it's a shebang, then a path to a list that *unix stores locations of all programs in.

On the first line of your text editor window, type:

```bash
#! /usr/bin/env bash
```
???
In most cases, your shebang will be that exact path plus the language you are using.
e.g.

`#! /usr/bin/env bash`

`#! /usr/bin/env python`

---

# Your first script!

For your first script we want the program to print "Hello world!"

How did we told bash to print something in screen?
--

```bash
#! /usr/bin/env bash

echo "Hello world"
```
save the file.

--

That's it! You've made your first script!

---
# How do you run a script?

Now to run the script, we do:

```bash
$ bash ./first_script.sh
```
--
```
Hello world
```

---
# Input Variables

So now we want to change our script to instead of saying `Hello world`, it say `Hello <your_name>`

So our script looked like:

```bash
#! /usr/bin/env bash

echo "Hello world"
```

We can use variables for the arguments passed to a script.

--

Wait... what are arguments??

--

It is a user suplied value that the script will use to perform the tasks

---
# Input Variables

In Bash, the arguments passed on the command line can be called `$1`,`$2`, `$3`...

`${1}` is the first argument

--

`${2}` is the second argument

--

`${3}` is the third argument

--

and so on.

--

Let's go back to our script and change the printing message

---
# Input Variables

This is our script from before:

```bash
#! /usr/bin/env bash



echo "Hello world"
```

--

First, we want to pass our name to the script as an argument.

---
# Input Variables

This is our script from before:

```bash
#! /usr/bin/env bash

name=${1}

echo "Hello world"
```

First, we want to pass our name to the script as an argument.

--

Then, we want to print out "Hello < name >" instead of "Hello World".

---
# Input Variables

This is our script from before:

```bash
#! /usr/bin/env bash

name=${1}

echo "Hello ${name}"
```

First, we want to pass our name to the script as an argument.

Then, we want to print out "Hello < name >" instead of "Hello World".

--

The script now needs an argument to run, so we will run:
```bash
$ bash ./first_script.sh Aida
```
--
```
Hello Aida
```

---
# Best practices when coding

There are a few best practices that you should follow when writing code, to ensure that anyone can understand your code.

--

- Comment your code: add a short description of the steps. So in our first_script.sh, we should include:

--

```bash
#! /usr/bin/env bash

## Read name from positional arguments
name=${1}

## Printing Hello and the specified variable into screen
echo "Hello ${name}"
```

--

- Give variables informative names.

--

- Try to have all bash variables in `${}`. This helps distinguish them visually and ensures all variables are interpreted correctly.

--

- Keep the code simple: try to simplify your code instead of having 1,000 lines
--

  - Avoid duplicating code.
  
---
# Recommended practice when writing code

- Add a help message. In our basic script, we could add the following:

```bash
#! /usr/bin/env bash

name=${1}

if [[ ${name} == "--help" || ${name} == "-h" ]]; then
  ## Print help message
  echo "This script print Hello <your_name> into screen."
  echo "To run it type: bash ./first_script.sh <your_name>"
else
  ## Printing Hello and the specified variable into screen
  echo "Hello ${name}"
 fi
```
--
You will often go back to old scripts and not remember the options and arguments they need.

Having helptext will make it easier to remember.

---
# Debugging your code

- Try your code outside the script

--

- Add print statements to check the variables/commands are rendering properly

--

- Write the script by its functional parts. 
 - Think what you want your script to do
 - Write/Draw the steps to do
 - Write code for the first step -> try it -> write code for the next step -> try it -> repeat until the end
 - Simplify your code

--

- Explain your code to someone else. Going through the logic of it will often make the problem obvious.
 - This is called the Rubber ducky approach, as many programmers have a rubber duck that they explain their code to.

---
# Things to keep in mind

- Code for the same task can be written in multiple ways

  - Some code is more **efficient** -> a.k.a runs faster.
  - Some code is more **readable**.
--

  - Some code is _both!_
--

  - Some code is neither...

--

- Practice makes perfect: the more you do it, the more you learn.

---
# Time to practice!

Your task now will be to generate a script to perform the image sorting that we have show you in this presentation.

**BUT:** This time you will need to make a subdirectory within each of the categories with the secondary description of the images!
> That is column 3 of the metadata file. (Artwork, Baby, Funny, Historical, Normal)

--

For this, please make a new directory and download the data again:

```bash
$ mkdir ~/Boosted-BBB-scripting
$ cd ~/Boosted-BBB-scripting

## Get images zip and metadata file
$ wget git.io/Boosted-BBB-images
$ wget git.io/Boosted-BBB-meta

## Unzip image folders and rename metadata file
$ unzip Boosted-BBB-images
$ mv Boosted-BBB-meta  ~/Boosted-BBB-scripting/Boosted-BBB-meta.tsv
```
> Mac users should use `curl -LO`

You are set up to start now!

---
# Our Proposed script!


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
      /*ratio: "16:9", from: https://github.com/gnab/remark/issues/86#issuecomment-36157045*/
      slideNumberFormat: (current, total) => `
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: ${current/total*100}%">
          </div>
        </div>
      `
    });
    </script>
  </body>
</html>
